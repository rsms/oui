/**
 * WebSocket-compatible interface to a comet hub.
 *
 * Events:
 * 
 *  open(Event, XMLHttpRequest)
 *    When the connection has been opened. The XMLHttpRequest argument represents the
 *    "polling" xhr.
 *
 *  message(Event, Object data, XMLHttpRequest)
 *    When a message is received.
 *
 *  error(Event, "recv"|"send", XMLHttpRequest, Exception)
 *    When a communication error occurs on XMLHttpRequest. If first argument is "send",
 *    the error occured from a send() operation. Otherwise while receiving data.
 *
 *  timeout(Event)
 *    When a polling event timed out. This is not an error and is immediately followed
 *    by a reconnect.
 *
 *  close(Event)
 *    When the connection has been closed.
 * 
 *  status(Event, int queued, int lastPublishInterval, int subscribers)
 *    Comet server status, (possibly) reported after each successful send() operation.
 * 
 */
CometSocket = function(url, pubURL) {
	this.subURL = (typeof url === 'string') ? url : '/msgq/sub';
	this.pubURL = (typeof pubURL === 'string') ? pubURL : this.subURL;
	this.minPollInterval = 500;
	this.lastMessageDate = null;
	this.subscribed = false;
	this.pollDelay = 10;
	this.pollTimeout = 3600000; // set to 0 for no timeout
	
	this._sendMsgCounter = 1;
	this._activeRequests = [];
	
	// to comply with WebSocket interface:
	this.bufferedAmount = 0;
	this.readyState = 0;
	this.on('open', function(){
		if (typeof this.onopen === 'function')
			this.onopen.apply(this, arguments);
	});
	this.on('message', function(){
		if (typeof this.onmessage === 'function')
			this.onmessage.apply(this, arguments);
	});
	this.on('close', function(){
		if (typeof this.onclose === 'function')
			this.onclose.apply(this, arguments);
	});
	
	// http://dev.w3.org/html5/websockets/#the-websocket-interface
	var self = this;
	setTimeout(function(){ self._open(); }, 10);
}

CometSocket.CONNECTING = 0;
CometSocket.OPEN = 1;
CometSocket.CLOSED = 2;

mix(CometSocket, EventEmitter, function(P){
	/**
	 * Send data
	 */
	P.send = function(objectOrString, dataType) {
		if(dataType === undefined)
			dataType = 'json';
		var contentType = 'application/x-www-form-urlencoded';
		if (dataType == 'json') {
			contentType = 'application/json';
			objectOrString = $.toJSON(objectOrString);
		}
		var msgid = this._sendMsgCounter++;
		var self = this;
		return $.ajax({
			type: 'POST',
			url: this.pubURL,
			data: objectOrString,
			contentType: contentType,
			dataType: "text", // Response data type
			timeout: 30000,
			/*beforeSend: function(r) {
				console.log('send: ['+msgid+'] sending')
			},*/
			success: function(rsp, textStatus){
				//console.log('send: ['+msgid+'] ok', rsp, r);
				// parse status message
				// Response body:
				// queued messages: 1
				// last requested: -1 sec. ago (-1=never)
				// active subscribers: 0
				rsp = rsp.replace(/(^[\t ]+|[\t ]+$)/gm, '').split(/[\r\n]+/);
				var status = [
					/*queued*/          parseInt(rsp[0].replace(/^.+: ([0-9]+).*$/, '\1')),
					/*lastPubInterval*/ parseInt(rsp[1].replace(/.+: ([0-9]+) .*$/, '\1')),
					/*subscribers*/     parseInt(rsp[2].replace(/.+: ([0-9]+).*$/, '\1'))
				];
				//console.log('self.remoteStatus =>', self.remoteStatus);
				self.emit('status', status);
			},
			error: function(r, textStatus, exc) {
				//console.log('send: ['+msgid+'] fail');
				self.emit('error', ['send', r, exc]);
			}/*,
			complete: function(r, textStatus) {
			}*/
		});
	}
	
	P.close = function() {
		if (!this.subscribed)
			return;
		this.subscribed = false;
		// deref, since it might be replaced while iterating:
		var v = this._activeRequests;
		for (var k in v)
			v[k].abort();
	}
	
	// --------------
	// Non-WebSocket methods:
	
	P.backoffPoll = function() {
		if (this.pollDelay < this.minPollInterval)
			this.pollDelay = this.minPollInterval;
		this.pollDelay *= 1.1;
		//console.log('backed off pollDelay to '+this.pollDelay);
	}
	
	
	// --------------
	// Private methods:
	
	P._open = function() {
		if (this.subscribed)
			return;
		this.subscribed = true;
		this._haveEmittedOpenEvent = false;
		// intially 200ms to avoid browser ui quirks:
		var self = this;
		setTimeout(function(){ self._poll(); }, 200);
	}
	
	P._updateLastMessageDate = function(r) {
		try {
			var lastmods = r.getResponseHeader('Last-Modified');
			if (typeof lastmods === 'string') {
				console.log('Last-Modified: '+lastmods);
				this.lastMessageDate = new Date(lastmods);
				this.lastMessageDate.setTime(this.lastMessageDate.getTime()+1000); // +1s
			}
		}
		catch (e) {
			console.log('warning: failed to read/parse Last-Modified', e);
		}
	}
	
	P._poll = function() {
		if (!this.subscribed)
			return;
		console.log('GET '+this.subURL);
		var _dateRequestSent = new Date();
		var self = this;
		if (self.readyState === CometSocket.CLOSED)
			self.readyState = CometSocket.CONNECTING;
		$.ajax({
			type: "GET",
			url: this.subURL,
			dataType: "json",
			timeout: this.pollTimeout,
			beforeSend: function(r) {
				// todo: save in cookie or similar, so when reloading the page, we dont get repeated messages
				if (self.lastMessageDate) {
					console.log('set: If-Modified-Since: '+self.lastMessageDate.toUTCString());
					r.setRequestHeader('If-Modified-Since', self.lastMessageDate.toUTCString());
				}
				self._activeRequestsAdd(r);
				if (self.readyState !== CometSocket.OPEN) {
					self.readyState = CometSocket.OPEN;
					self.emit('open', [r]);
				}
				this.r = r;
			},
			success: function(rsp, textStatus){
				try {
					if (this.r.status < 600 && this.r.status >= 400) {
						// error-type of response
						self.backoffPoll();
						console.log('Warning: '+this.r.status, this.r.responseText);
						self.emit('error', ['recv', this.r, exc]);
					}
					else {
						// update lastMessageDate
						self._updateLastMessageDate(this.r);
						self.pollDelay = 10; // reset
						self.emit('message', [rsp, this.r]);
					}
				}
				catch (exc) {
					console.log('error in CometSocket._poll -- jquery.ajax:success:', exc);
					self.emit('error', ['recv', this.r, exc]);
				}
			},
			error: function(r, textStatus, exc) {
				if (textStatus == 'timeout') {
					self.emit('timeout');
				}
				else {
					self._updateLastMessageDate(this.r);
					console.log('message request failed '+textStatus
						+ (typeof exc != 'undefined' ? ' '+exc : ''));
					self.backoffPoll();
					self.emit('error', ['recv', r, exc]);
				}
			},
			complete: function(r, textStatus) {
				self._activeRequestsRemove(r);
				
				// abort if no longer subscribed
				if (!self.subscribed)
					return;
				
				// schedule next poll
				var now = new Date();
				var timespent = now.getTime() - _dateRequestSent.getTime();
				delay = 10;
				if (timespent < self.minPollInterval)
					delay = self.minPollInterval-timespent;
				if (delay < self.pollDelay)
					delay = self.pollDelay;
				setTimeout(function(){ self._poll(); }, delay); // avoid blowing js stack
			}
		});
	}
	
	P._activeRequestsAdd = function(r) {
		this._activeRequests.push(r);
	}
	
	P._activeRequestsRemove = function(r) {
		var v = [];
		for (var k in this._activeRequests) {
			this._activeRequests.push(r);
			if (r != this._activeRequests[k])
				v.push(this._activeRequests[k]);
		}
		this._activeRequests = v;
		if (!this.subscribed && this._activeRequests.length === 0 && self.readyState !== CometSocket.CLOSED) {
			this.readyState = CometSocket.CLOSED;
			this.emit('close');
		}
	}

});
